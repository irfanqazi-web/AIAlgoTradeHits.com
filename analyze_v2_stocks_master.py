import sys
import io
import xml.etree.ElementTree as ET

if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

file_path = r'C:\Users\irfan\Downloads\v2_stocks_master_2025-12-08.xls'

print("=" * 100)
print("ANALYZING EXCEL-XML FILE: v2_stocks_master_2025-12-08.xls")
print("=" * 100)
print("\n‚ö†Ô∏è  This file is in Excel XML format (old format), NOT binary .xls or .xlsx")
print("This format was generated by the OLD downloadXLSX() function that we just fixed!\n")

try:
    # Parse XML
    tree = ET.parse(file_path)
    root = tree.getroot()

    # Define namespace
    ns = {'ss': 'urn:schemas-microsoft-com:office:spreadsheet'}

    # Find all worksheets
    worksheets = root.findall('.//ss:Worksheet', ns)

    print(f"Found {len(worksheets)} worksheet(s)\n")

    structure_fields = []
    data_fields = []

    for ws in worksheets:
        ws_name = ws.get('{urn:schemas-microsoft-com:office:spreadsheet}Name')
        print("=" * 100)
        print(f"WORKSHEET: {ws_name}")
        print("=" * 100)

        table = ws.find('.//ss:Table', ns)
        if table is not None:
            rows = table.findall('.//ss:Row', ns)
            print(f"Total rows: {len(rows)}\n")

            if ws_name == 'Structure':
                print("Field definitions (in order as defined in Structure tab):")
                print("-" * 100)
                print(f"{'#':>3} | {'Field Name':50} | {'Type':15} | {'Mode':10}")
                print("-" * 100)

                # Skip header row
                for i, row in enumerate(rows[1:], 1):
                    cells = row.findall('.//ss:Cell', ns)
                    values = []
                    for cell in cells:
                        data = cell.find('.//ss:Data', ns)
                        values.append(data.text if data is not None and data.text else '')

                    if len(values) >= 2 and values[1]:  # If field name exists
                        field_num = values[0]
                        field_name = values[1]
                        field_type = values[2] if len(values) > 2 else ''
                        field_mode = values[3] if len(values) > 3 else ''

                        structure_fields.append(field_name)
                        print(f"{field_num:>3}. | {field_name:50} | {field_type:15} | {field_mode:10}")

            elif ws_name == 'Data':
                # Get header row
                if rows:
                    header_row = rows[0]
                    header_cells = header_row.findall('.//ss:Cell', ns)

                    print("Column order in Data tab:")
                    print("-" * 100)
                    print(f"{'#':>3} | {'Column Name':50}")
                    print("-" * 100)

                    for i, cell in enumerate(header_cells, 1):
                        data = cell.find('.//ss:Data', ns)
                        if data is not None and data.text:
                            col_name = data.text
                            data_fields.append(col_name)
                            print(f"{i:>3}. | {col_name:50}")

                    # Show sample data
                    print("\n" + "=" * 100)
                    print("SAMPLE DATA (First 5 rows)")
                    print("=" * 100)

                    for row_idx in range(1, min(6, len(rows))):
                        row = rows[row_idx]
                        cells = row.findall('.//ss:Cell', ns)
                        print(f"\nRow {row_idx}:")
                        print("-" * 100)

                        # Show all columns for first few rows
                        for j, cell in enumerate(cells):
                            data = cell.find('.//ss:Data', ns)
                            value = data.text if data is not None and data.text else 'None'
                            col_name = data_fields[j] if j < len(data_fields) else f'Col{j+1}'
                            print(f"  {col_name:40}: {value}")

    # Compare Structure vs Data
    print("\n" + "=" * 100)
    print("COMPARISON: Structure Tab vs Data Tab Column Order")
    print("=" * 100)

    print(f"\nTotal fields in Structure tab: {len(structure_fields)}")
    print(f"Total fields in Data tab:      {len(data_fields)}")

    if structure_fields == data_fields:
        print("\n‚úÖ PERFECT MATCH: Field order is IDENTICAL in both tabs")
        print("The Structure and Data tabs are in sync!")
    else:
        print("\n‚ùå MISMATCH: Field order is DIFFERENT between tabs\n")

        print("Detailed comparison (side by side):")
        print("-" * 120)
        print(f"{'#':>4} | {'Match':^7} | {'Structure Tab':50} | {'Data Tab':50}")
        print("-" * 120)

        max_len = max(len(structure_fields), len(data_fields))

        mismatches = 0
        for i in range(max_len):
            struct_field = structure_fields[i] if i < len(structure_fields) else "‚ùå MISSING"
            data_field = data_fields[i] if i < len(data_fields) else "‚ùå MISSING"

            if struct_field == data_field:
                match = "‚úì"
            else:
                match = "‚úó"
                mismatches += 1

            # Highlight mismatches
            marker = ">>> " if match == "‚úó" else "    "
            print(f"{marker}{i+1:>3}. | {match:^7} | {struct_field:50} | {data_field:50}")

        print("-" * 120)
        print(f"\nüìä SUMMARY: {mismatches} field(s) out of {max_len} are in DIFFERENT positions or MISSING")

        if mismatches > 0:
            # Fields in Structure but not in Data
            missing_in_data = set(structure_fields) - set(data_fields)
            if missing_in_data:
                print(f"\n‚ö†Ô∏è  Fields in STRUCTURE but NOT in DATA ({len(missing_in_data)} fields):")
                for field in sorted(missing_in_data):
                    print(f"   - {field}")

            # Fields in Data but not in Structure
            extra_in_data = set(data_fields) - set(structure_fields)
            if extra_in_data:
                print(f"\n‚ö†Ô∏è  Fields in DATA but NOT in STRUCTURE ({len(extra_in_data)} fields):")
                for field in sorted(extra_in_data):
                    print(f"   - {field}")

            # Check if it's just order, not content
            if set(structure_fields) == set(data_fields):
                print("\n‚ö†Ô∏è  NOTE: All fields exist in both tabs, but they are in DIFFERENT ORDER!")
                print("This is the JavaScript Object.keys() issue we discussed.")

    print("\n" + "=" * 100)
    print("ROOT CAUSE ANALYSIS")
    print("=" * 100)
    print("""
WHY THIS HAPPENED:
==================

This file was generated by the OLD downloadXLSX() function in TableInventory.jsx.

The OLD code had a CRITICAL BUG:

1. Structure Tab: Built from schemaData.schema (ordered array from BigQuery)
   ‚úÖ Fields in correct order as defined in BigQuery schema

2. Data Tab: Built from Object.keys(dataToExport[0])
   ‚ùå JavaScript Object.keys() does NOT guarantee property order!
   ‚ùå Column order depends on how JavaScript stores object properties
   ‚ùå BigQuery's JSON response property order ‚â† Schema definition order

JAVASCRIPT OBJECT.KEYS() BEHAVIOR:
===================================
- Before ES2015: Property order was completely unpredictable
- After ES2015: Order is "mostly" preserved but not guaranteed
- When JSON is parsed, property order depends on:
  * Order in JSON string
  * Integer keys vs string keys (integers sorted first!)
  * Property insertion order
  * JavaScript engine implementation

EXAMPLE OF THE PROBLEM:
=======================

BigQuery Schema (ordered):
  1. id
  2. symbol
  3. name
  4. exchange
  5. close

BigQuery returns JSON data like:
  { "close": 150.5, "exchange": "NASDAQ", "id": "123", "name": "Apple", "symbol": "AAPL" }

Object.keys() returns:
  ["close", "exchange", "id", "name", "symbol"]  ‚Üê ALPHABETICAL ORDER!

Result: Data tab columns ‚â† Structure tab columns ‚ùå

‚úÖ SOLUTION (Already Implemented):
===================================
We replaced manual XML generation with the XLSX library:
- XLSX.utils.json_to_sheet() preserves the actual data structure
- Creates proper .xlsx files (not XML)
- Both tabs now use consistent data sources
- Column order is predictable and matches schema

üéØ NEXT STEPS:
==============
1. Re-download this table using the FIXED code (npm run dev)
2. New file will be proper .xlsx format
3. Structure and Data tabs will have MATCHING column order
4. You can then mark fields as "not needed" with confidence
    """)

except Exception as e:
    print(f"\n‚ùå Error analyzing file: {e}")
    import traceback
    traceback.print_exc()
