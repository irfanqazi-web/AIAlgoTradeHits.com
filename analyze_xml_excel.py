import sys
import io
import xml.etree.ElementTree as ET

if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

file_path = r'C:\Users\irfan\Downloads\weekly_stocks_all_2025-12-08.xls'

print("=" * 100)
print("ANALYZING EXCEL-XML FILE: weekly_stocks_all_2025-12-08.xls")
print("=" * 100)
print("\nâš ï¸  This file is in Excel XML format (old format), NOT binary .xls or .xlsx")
print("This format was generated by the OLD downloadXLSX() function that we just fixed!\n")

try:
    # Parse XML
    tree = ET.parse(file_path)
    root = tree.getroot()

    # Define namespace
    ns = {'ss': 'urn:schemas-microsoft-com:office:spreadsheet'}

    # Find all worksheets
    worksheets = root.findall('.//ss:Worksheet', ns)

    print(f"Found {len(worksheets)} worksheet(s)\n")

    structure_fields = []
    data_fields = []

    for ws in worksheets:
        ws_name = ws.get('{urn:schemas-microsoft-com:office:spreadsheet}Name')
        print("=" * 100)
        print(f"WORKSHEET: {ws_name}")
        print("=" * 100)

        table = ws.find('.//ss:Table', ns)
        if table is not None:
            rows = table.findall('.//ss:Row', ns)
            print(f"Total rows: {len(rows)}\n")

            if ws_name == 'Structure':
                print("Field definitions (in order):")
                print("-" * 100)

                # Skip header row
                for i, row in enumerate(rows[1:], 1):
                    cells = row.findall('.//ss:Cell', ns)
                    values = []
                    for cell in cells:
                        data = cell.find('.//ss:Data', ns)
                        values.append(data.text if data is not None and data.text else '')

                    if len(values) >= 2 and values[1]:  # If field name exists
                        field_num = values[0]
                        field_name = values[1]
                        field_type = values[2] if len(values) > 2 else ''
                        field_mode = values[3] if len(values) > 3 else ''

                        structure_fields.append(field_name)
                        print(f"{field_num:>3}. {field_name:40} | Type: {field_type:10} | Mode: {field_mode}")

                    if i >= 50:  # Limit output
                        if len(rows) > 51:
                            print(f"... and {len(rows) - 51} more fields")
                        break

            elif ws_name == 'Data':
                # Get header row
                if rows:
                    header_row = rows[0]
                    header_cells = header_row.findall('.//ss:Cell', ns)

                    print("Column order in Data tab:")
                    print("-" * 100)

                    for i, cell in enumerate(header_cells, 1):
                        data = cell.find('.//ss:Data', ns)
                        if data is not None and data.text:
                            col_name = data.text
                            data_fields.append(col_name)
                            print(f"{i:3}. {col_name}")

                    # Show sample data
                    print("\nSample data (first 3 rows):")
                    print("-" * 100)
                    for row_idx in range(1, min(4, len(rows))):
                        row = rows[row_idx]
                        cells = row.findall('.//ss:Cell', ns)
                        print(f"\nRow {row_idx}:")
                        for j, cell in enumerate(cells[:10]):  # First 10 columns
                            data = cell.find('.//ss:Data', ns)
                            value = data.text if data is not None and data.text else 'None'
                            col_name = data_fields[j] if j < len(data_fields) else f'Col{j+1}'
                            print(f"  {col_name}: {value}")

    # Compare Structure vs Data
    print("\n" + "=" * 100)
    print("COMPARISON: Structure Tab vs Data Tab")
    print("=" * 100)

    print(f"\nTotal fields in Structure tab: {len(structure_fields)}")
    print(f"Total fields in Data tab:      {len(data_fields)}")

    if structure_fields == data_fields:
        print("\nâœ… MATCH: Field order is IDENTICAL in both tabs")
    else:
        print("\nâŒ MISMATCH: Field order is DIFFERENT between tabs\n")

        print("Detailed comparison (side by side):")
        print("-" * 100)
        print(f"{'#':4} | {'Match':5} | {'Structure Tab':50} | {'Data Tab':50}")
        print("-" * 100)

        max_len = max(len(structure_fields), len(data_fields))

        mismatches = 0
        for i in range(max_len):
            struct_field = structure_fields[i] if i < len(structure_fields) else "MISSING"
            data_field = data_fields[i] if i < len(data_fields) else "MISSING"

            match = "âœ“" if struct_field == data_field else "âœ—"
            if match == "âœ—":
                mismatches += 1

            print(f"{i+1:3}. | {match:^5} | {struct_field:50} | {data_field:50}")

        print(f"\nðŸ“Š Summary: {mismatches} field(s) out of {max_len} are in different positions")

        # Fields in Structure but not in Data
        missing_in_data = set(structure_fields) - set(data_fields)
        if missing_in_data:
            print(f"\nâš ï¸ Fields in Structure but NOT in Data ({len(missing_in_data)} fields):")
            for field in missing_in_data:
                print(f"   - {field}")

        # Fields in Data but not in Structure
        extra_in_data = set(data_fields) - set(structure_fields)
        if extra_in_data:
            print(f"\nâš ï¸ Fields in Data but NOT in Structure ({len(extra_in_data)} fields):")
            for field in extra_in_data:
                print(f"   - {field}")

    print("\n" + "=" * 100)
    print("ROOT CAUSE ANALYSIS")
    print("=" * 100)
    print("""
This file was generated by the OLD downloadXLSX() function that used manual XML generation.

The problem was in TableInventory.jsx (lines 110-245 in the OLD code):
- It manually constructed Excel XML with string concatenation
- The Structure tab was built correctly from schemaData.schema
- BUT the Data tab used Object.keys(dataToExport[0]) for headers
- Object.keys() returns properties in an UNPREDICTABLE order in JavaScript!
- This caused the column order mismatch

âœ… SOLUTION (Already implemented):
We replaced the manual XML generation with the proper XLSX library (xlsx npm package).
The XLSX library:
1. Preserves field order correctly
2. Generates proper .xlsx files (not XML)
3. Handles data types properly
4. Auto-sizes columns

ðŸŽ¯ NEXT STEPS:
1. Re-download this table using the FIXED Excel download feature
2. The new file will have matching Structure and Data tab columns
3. The new file will be a proper .xlsx format
    """)

except Exception as e:
    print(f"\nâŒ Error analyzing file: {e}")
    import traceback
    traceback.print_exc()
